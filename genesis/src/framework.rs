use {
    crate::MovedVm,
    alloy::primitives::address,
    aptos_framework::{ReleaseBundle, ReleasePackage},
    bytes::Bytes,
    move_binary_format::errors::VMError,
    move_core_types::{
        account_address::AccountAddress,
        effects::{ChangeSet, Op},
        ident_str,
        language_storage::ModuleId,
        value::MoveValue,
    },
    move_vm_runtime::{
        AsUnsyncCodeStorage, ModuleStorage, StagingModuleStorage, VerifiedModuleBundle,
        module_traversal::{TraversalContext, TraversalStorage},
        move_vm::MoveVM,
        session::Session,
    },
    move_vm_types::gas::UnmeteredGasMeter,
    moved_state::{ResolverBasedModuleBytesStorage, State},
    once_cell::sync::Lazy,
    std::{collections::BTreeMap, fs, path::PathBuf},
    sui_framework::SystemPackage,
    sui_types::base_types::ObjectID,
};

pub const CRATE_ROOT: &str = env!("CARGO_MANIFEST_DIR");
pub const APTOS_SNAPSHOT_NAME: &str = "aptos.mrb";
pub const SUI_SNAPSHOT_NAME: &str = "sui.mrb";
pub const L2_PACKAGE_NAME: &str = "L2";
pub const FRAMEWORK_ADDRESS: AccountAddress = moved_evm_ext::FRAMEWORK_ADDRESS;
pub const L2_LOWEST_ADDRESS: AccountAddress =
    eth_address(&address!("4200000000000000000000000000000000000000").0.0);
pub const L2_HIGHEST_ADDRESS: AccountAddress =
    eth_address(&address!("42000000000000000000000000000000000000ff").0.0);
pub const TOKEN_ADDRESS: AccountAddress = small_account_address(0x13);
pub const TOKEN_OBJECT_ADDRESS: AccountAddress = small_account_address(0x14);
pub const SUI_STDLIB_ADDRESS: AccountAddress = small_account_address(0x21);
pub const SUI_FRAMEWORK_ADDRESS: AccountAddress = small_account_address(0x22);
pub const SUI_STDLIB_PACKAGE_ID: ObjectID = small_object_id(0x21);
pub const SUI_FRAMEWORK_PACKAGE_ID: ObjectID = small_object_id(0x22);

// The `head.mrb` file is generated by running the following inside an aptos-core repo
// cargo run --package aptos-framework -- release
static APTOS_RELEASE_BUNDLE: Lazy<ReleaseBundle> = Lazy::new(|| {
    let snapshot_path = PathBuf::from(CRATE_ROOT).join(APTOS_SNAPSHOT_NAME);
    let binary = fs::read(snapshot_path).expect("Aptos snapshot file should exist");
    bcs::from_bytes(&binary).expect("bcs should deserialize Aptos file")
});

static SUI_SYSTEM_PACKAGES: Lazy<BTreeMap<ObjectID, SystemPackage>> = Lazy::new(|| {
    let snapshot_path = PathBuf::from(CRATE_ROOT).join(SUI_SNAPSHOT_NAME);
    let binary = fs::read(snapshot_path).expect("Sui snapshot file should exist");
    let snapshot: Vec<SystemPackage> =
        bcs::from_bytes(&binary).expect("bcs should deserialize Sui snapshot file");
    snapshot.into_iter().map(|pkg| (pkg.id, pkg)).collect()
});

const fn eth_address(value: &[u8; 20]) -> AccountAddress {
    let mut buf = [0u8; 32];
    let mut i = 0;
    while i < 20 {
        buf[i + 12] = value[i];
        i += 1;
    }
    AccountAddress::new(buf)
}

const fn small_account_address(value: u8) -> AccountAddress {
    let mut buf = [0u8; 32];
    buf[31] = value;
    AccountAddress::new(buf)
}

const fn small_object_id(value: u8) -> ObjectID {
    ObjectID::from_single_byte(value)
}

/// Returns the Aptos framework release bundle
pub fn load_aptos_framework_snapshot() -> &'static ReleaseBundle {
    &APTOS_RELEASE_BUNDLE
}

/// Returns the Sui framework release bundle
pub fn load_sui_framework_snapshot() -> &'static BTreeMap<ObjectID, SystemPackage> {
    &SUI_SYSTEM_PACKAGES
}

/// Initializes the blockchain state with Aptos and Sui frameworks.
pub fn init_state(vm: &MovedVm, state: &mut impl State) -> ChangeSet {
    deploy_framework(vm, state).expect("All bundle modules should be valid")
}

pub trait CreateMoveVm {
    fn create_move_vm(&self) -> Result<MoveVM, VMError>;
}

fn deploy_framework(moved_vm: &MovedVm, state: &mut impl State) -> Result<ChangeSet, VMError> {
    let mut aptos_changeset = deploy_aptos_framework(state, moved_vm)?;
    let eth_changeset = initialize_eth_token(state, moved_vm)?;

    let sui_changeset = deploy_sui_framework(state, moved_vm)?;

    aptos_changeset
        .squash(eth_changeset)
        .expect("Aptos and EthToken changes should not conflict");

    aptos_changeset
        .squash(sui_changeset)
        .expect("Aptos and Sui changes should not conflict");

    Ok(aptos_changeset)
}

fn initialize_eth_token(state: &mut impl State, moved_vm: &MovedVm) -> Result<ChangeSet, VMError> {
    let vm = moved_vm.create_move_vm()?;
    // `init_module` doesn't produce any table changes, so we don't need the extensions
    let mut session = vm.new_session(state.resolver());
    let traversal_storage = TraversalStorage::new();
    let mut traversal_context = TraversalContext::new(&traversal_storage);
    let module_bytes_storage = ResolverBasedModuleBytesStorage::new(state.resolver());
    let code_storage = module_bytes_storage.as_unsync_code_storage(moved_vm);
    let module = ModuleId::new(FRAMEWORK_ADDRESS, ident_str!("eth_token").into());
    let function_name = ident_str!("init_module");
    let args = bcs::to_bytes(&MoveValue::Signer(FRAMEWORK_ADDRESS))
        .expect("Serialization of constant must succeed");
    session.execute_function_bypass_visibility(
        &module,
        function_name,
        Vec::new(),
        vec![args],
        &mut UnmeteredGasMeter,
        &mut traversal_context,
        &code_storage,
    )?;
    let change_set = session.finish(&code_storage)?;
    Ok(change_set)
}

fn initialize_package(
    session: &mut Session,
    module_storage: &impl ModuleStorage,
    addr: AccountAddress,
    traversal_context: &mut TraversalContext,
    package: &ReleasePackage,
) {
    let module = &ModuleId::new(FRAMEWORK_ADDRESS, ident_str!("code").into());
    let function_name = ident_str!("initialize");
    session
        .execute_function_bypass_visibility(
            module,
            function_name,
            vec![],
            vec![
                MoveValue::Signer(FRAMEWORK_ADDRESS)
                    .simple_serialize()
                    .unwrap(),
                MoveValue::Signer(addr).simple_serialize().unwrap(),
                bcs::to_bytes(package.package_metadata()).unwrap(),
            ],
            &mut UnmeteredGasMeter,
            traversal_context,
            module_storage,
        )
        .unwrap();
}

fn deploy_aptos_framework(
    state: &mut impl State,
    moved_vm: &MovedVm,
) -> Result<ChangeSet, VMError> {
    let framework = load_aptos_framework_snapshot();
    // Iterate over the bundled packages in the Aptos framework
    let mut framework_writes = ChangeSet::new();
    for package in &framework.packages {
        let module_bytes_storage = ResolverBasedModuleBytesStorage::new(state.resolver());
        let module_storage = module_bytes_storage.as_unsync_code_storage(moved_vm);
        let modules = package.sorted_code_and_modules();
        let package_writes = if package.name() == L2_PACKAGE_NAME {
            // L2 package have self-contained independent modules
            let mut l2_writes = ChangeSet::new();
            for (bytecode, module) in modules {
                let code = bytecode.to_vec();
                let sender = module.self_id().address;
                assert!(
                    sender.ge(&L2_LOWEST_ADDRESS) && sender.le(&L2_HIGHEST_ADDRESS),
                    "L2 module {sender} should be within the allowed address range."
                );
                let staged_module_storage =
                    StagingModuleStorage::create(&sender, &module_storage, vec![code.into()])?;
                let bundle = staged_module_storage.release_verified_module_bundle();
                let l2_single_module_writes =
                    convert_bundle_into_module_ops(bundle, &module_storage)?;
                l2_writes.squash(l2_single_module_writes).unwrap();
            }
            l2_writes
        } else {
            // Address from the first module is sufficient as they're the same within the package
            let sender = *modules
                .first()
                .expect("Package has at least one module")
                .1
                .self_id()
                .address();

            assert!(
                sender == FRAMEWORK_ADDRESS
                    || sender == TOKEN_ADDRESS
                    || sender == TOKEN_OBJECT_ADDRESS,
                "The framework should be deployed to a statically known address. {sender} not known."
            );

            let code = modules
                .into_iter()
                .map(|(code, _)| code.to_vec().into())
                .collect::<Vec<_>>();

            let staged_module_storage =
                StagingModuleStorage::create(&sender, &module_storage, code)?;
            let bundle = staged_module_storage.release_verified_module_bundle();
            convert_bundle_into_module_ops(bundle, &module_storage)?
        };
        // We need to add changes on a package-by-package basis so that other packages in the framework
        // can link against previous ones, but also pass it outside for genesis image generation
        state.apply(package_writes.clone()).unwrap();
        framework_writes
            .squash(package_writes)
            .expect("Packages in framework should not conflict with each other");
    }

    // Initialization is done after actual publishing so that the resolver sees all the packages
    // for linking
    let vm = moved_vm.create_move_vm()?;
    let module_bytes_storage = ResolverBasedModuleBytesStorage::new(state.resolver());
    let code_storage = module_bytes_storage.as_unsync_code_storage(moved_vm);
    // `initialize` doesn't produce any table changes either, so we don't need the extensions
    let mut session = vm.new_session(state.resolver());
    let traversal_storage = TraversalStorage::new();
    let mut traversal_context = TraversalContext::new(&traversal_storage);
    for pack in &framework.packages {
        let addr = *pack
            .sorted_code_and_modules()
            .first()
            .unwrap()
            .1
            .self_id()
            .address();
        initialize_package(
            &mut session,
            &code_storage,
            addr,
            &mut traversal_context,
            pack,
        );
    }
    let session_changes = session.finish(&code_storage)?;
    framework_writes
        .squash(session_changes)
        .expect("Initialization logic should not conflict with module writes");
    Ok(framework_writes)
}

fn deploy_sui_framework(state: &mut impl State, moved_vm: &MovedVm) -> Result<ChangeSet, VMError> {
    let snapshots = load_sui_framework_snapshot();
    let module_bytes_storage = ResolverBasedModuleBytesStorage::new(state.resolver());
    let module_storage = module_bytes_storage.as_unsync_code_storage(moved_vm);
    let mut total_writes = ChangeSet::new();

    let stdlib = snapshots
        .get(&SUI_STDLIB_PACKAGE_ID)
        .expect("Sui Move Stdlib package should exist in snapshot")
        .to_owned();
    let staged_stdlib_storage = StagingModuleStorage::create(
        &SUI_STDLIB_ADDRESS,
        &module_storage,
        stdlib
            .bytes
            .into_iter()
            .map(|module| module.into())
            .collect(),
    )?;
    let bundle = staged_stdlib_storage.release_verified_module_bundle();
    let stdlib_writes = convert_bundle_into_module_ops(bundle, &module_storage)?;
    state.apply(stdlib_writes.clone()).unwrap();
    total_writes
        .squash(stdlib_writes)
        .expect("Sui stdlib can be squashed with empty change set");

    // Storage needs to be redeclared to mask the first borrow
    let module_bytes_storage = ResolverBasedModuleBytesStorage::new(state.resolver());
    let module_storage = module_bytes_storage.as_unsync_code_storage(moved_vm);
    let framework = snapshots
        .get(&SUI_FRAMEWORK_PACKAGE_ID)
        .expect("Sui Framework package should exist in snapshot")
        .to_owned();
    let staged_framework_storage = StagingModuleStorage::create(
        &SUI_FRAMEWORK_ADDRESS,
        &module_storage,
        framework
            .bytes
            .into_iter()
            .map(|module| module.into())
            .collect(),
    )?;
    let bundle = staged_framework_storage.release_verified_module_bundle();
    let framework_writes = convert_bundle_into_module_ops(bundle, &module_storage)?;
    state.apply(framework_writes.clone()).unwrap();
    total_writes
        .squash(framework_writes)
        .expect("Sui framework can be squashed with stdlib");

    Ok(total_writes)
}

fn convert_bundle_into_module_ops(
    bundle: VerifiedModuleBundle<ModuleId, Bytes>,
    module_storage: &impl ModuleStorage,
) -> Result<ChangeSet, VMError> {
    let mut writes = ChangeSet::new();
    for (module_id, bytes) in bundle.into_iter() {
        let addr = module_id.address();
        let name = module_id.name();

        let module_exists = module_storage.check_module_exists(addr, name)?;
        let op = if module_exists {
            Op::Modify(bytes)
        } else {
            Op::New(bytes)
        };
        writes.add_module_op(module_id, op).unwrap();
    }
    Ok(writes)
}

#[cfg(test)]
mod tests {
    use {super::*, crate::vm::MovedVm, moved_state::InMemoryState};

    // Aptos framework has 145 modules and Sui has 69. They are kept mutually exclusive.
    const APTOS_MODULES_LEN: usize = 145;
    const SUI_MODULES_LEN: usize = 69;
    const TOTAL_MODULES_LEN: usize = APTOS_MODULES_LEN + SUI_MODULES_LEN;

    #[test]
    fn test_deploy_framework() {
        let aptos_framework_len = load_aptos_framework_snapshot()
            .code_and_compiled_modules()
            .len();
        assert_eq!(aptos_framework_len, APTOS_MODULES_LEN);
        let sui_framework_len = load_sui_framework_snapshot()
            .iter()
            .flat_map(|(_id, pkg)| pkg.modules())
            .count();
        assert_eq!(sui_framework_len, SUI_MODULES_LEN);

        let mut state = InMemoryState::new();
        let vm = MovedVm::new(&Default::default());
        let change_set = deploy_framework(&vm, &mut state).unwrap();
        assert_eq!(change_set.modules().count(), TOTAL_MODULES_LEN);
    }
}
