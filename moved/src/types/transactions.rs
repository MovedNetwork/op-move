use {
    crate::{primitives::ToEthAddress, Error, InvalidTransactionCause, UserError},
    alloy_consensus::{Signed, Transaction, TxEip1559, TxEip2930, TxEnvelope, TxLegacy},
    alloy_eips::eip2930::AccessList,
    alloy_primitives::{Address, Bytes, Keccak256, Log, LogData, TxKind, B256, U256, U64},
    alloy_rlp::{Buf, Decodable, Encodable, RlpDecodable, RlpEncodable},
    aptos_types::{
        contract_event::ContractEvent,
        transaction::{Module, Script},
    },
    move_core_types::{effects::ChangeSet, language_storage::TypeTag},
    serde::{Deserialize, Serialize},
};

const DEPOSITED_TYPE_BYTE: u8 = 0x7e;

/// OP-stack special transactions defined in
/// https://specs.optimism.io/protocol/deposits.html#the-deposited-transaction-type
#[derive(Debug, PartialEq, Eq, Clone, Deserialize, Serialize, RlpDecodable, RlpEncodable)]
pub struct DepositedTx {
    pub source_hash: B256,
    pub from: Address,
    pub to: Address,
    pub mint: U256,
    pub value: U256,
    pub gas: U64,
    pub is_system_tx: bool,
    pub data: Bytes,
}

/// Same as `alloy_consensus::TxEnvelope` except extended to
/// include the new Deposited transaction defined in OP-stack.
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ExtendedTxEnvelope {
    Canonical(TxEnvelope),
    DepositedTx(DepositedTx),
}

impl Encodable for ExtendedTxEnvelope {
    fn length(&self) -> usize {
        match self {
            Self::Canonical(tx) => tx.length(),
            Self::DepositedTx(tx) => tx.length() + 1,
        }
    }

    fn encode(&self, out: &mut dyn alloy_rlp::BufMut) {
        match self {
            Self::Canonical(tx) => {
                // For some reason Alloy double encodes the transaction
                // by default. So we use their default method then decode
                // one level.
                let mut buf = Vec::with_capacity(tx.length());
                tx.encode(&mut buf);
                let bytes = Bytes::decode(&mut buf.as_slice()).expect("Must be RLP decodable");
                out.put_slice(&bytes);
            }
            Self::DepositedTx(tx) => {
                out.put_u8(DEPOSITED_TYPE_BYTE);
                tx.encode(out);
            }
        }
    }
}

impl Decodable for ExtendedTxEnvelope {
    fn decode(buf: &mut &[u8]) -> alloy_rlp::Result<Self> {
        match buf.first().copied() {
            Some(DEPOSITED_TYPE_BYTE) => {
                buf.advance(1);
                let tx = DepositedTx::decode(buf)?;
                Ok(Self::DepositedTx(tx))
            }
            _ => {
                let tx = TxEnvelope::decode(buf)?;
                Ok(Self::Canonical(tx))
            }
        }
    }
}

#[derive(Debug)]
pub struct TransactionExecutionOutcome {
    /// The final outcome of the transaction execution.
    ///
    /// * In case of invalid user input, the result variant is set to [`Err`] containing the actual
    /// [`UserError`].
    /// * Otherwise, the result variant is set to [`Ok`] containing no data represented by an empty
    /// tuple.
    pub vm_outcome: Result<(), UserError>,
    /// All changes to accounts and resources generated by the transaction execution to be applied
    /// to Move blockchain state.
    pub changes: ChangeSet,
    /// Total amount of gas spent during the transaction execution.
    pub gas_used: u64,
    /// All emitted Move events converted to Ethereum logs.
    pub logs: Vec<Log<LogData>>,
}

impl TransactionExecutionOutcome {
    pub fn new(
        vm_outcome: Result<(), UserError>,
        changes: ChangeSet,
        gas_used: u64,
        logs: Vec<Log<LogData>>,
    ) -> Self {
        Self {
            vm_outcome,
            changes,
            gas_used,
            logs,
        }
    }
}

pub struct NormalizedEthTransaction {
    pub signer: Address,
    pub to: TxKind,
    pub nonce: u64,
    pub value: U256,
    pub data: Bytes,
    pub chain_id: Option<u64>,
    gas_limit: U256,
    pub max_priority_fee_per_gas: U256,
    pub max_fee_per_gas: U256,
    pub access_list: AccessList,
}

impl NormalizedEthTransaction {
    pub fn gas_limit(&self) -> u64 {
        // Gas limit cannot be larger than a `u64`, so
        // if any higher limb is non-zero simply return `u64::MAX`.
        match self.gas_limit.into_limbs() {
            [x, 0, 0, 0] => x,
            _ => u64::MAX,
        }
    }
}

impl TryFrom<TxEnvelope> for NormalizedEthTransaction {
    type Error = Error;

    fn try_from(tx: TxEnvelope) -> Result<Self, Self::Error> {
        Ok(match tx {
            TxEnvelope::Eip1559(tx) => tx.try_into()?,
            TxEnvelope::Eip2930(tx) => tx.try_into()?,
            TxEnvelope::Legacy(tx) => tx.try_into()?,
            TxEnvelope::Eip4844(_) => Err(InvalidTransactionCause::UnsupportedType)?,
            t => Err(InvalidTransactionCause::UnknownType(t.tx_type()))?,
        })
    }
}

impl TryFrom<Signed<TxEip1559>> for NormalizedEthTransaction {
    type Error = Error;

    fn try_from(value: Signed<TxEip1559>) -> Result<Self, Self::Error> {
        let address = value.recover_signer()?;
        let tx = value.strip_signature();

        Ok(Self {
            signer: address,
            to: tx.to,
            nonce: tx.nonce,
            value: tx.value,
            chain_id: tx.chain_id(),
            gas_limit: U256::from(tx.gas_limit()),
            max_priority_fee_per_gas: U256::from(tx.max_priority_fee_per_gas),
            max_fee_per_gas: U256::from(tx.max_fee_per_gas),
            data: tx.input,
            access_list: tx.access_list,
        })
    }
}

impl TryFrom<Signed<TxEip2930>> for NormalizedEthTransaction {
    type Error = Error;

    fn try_from(value: Signed<TxEip2930>) -> Result<Self, Self::Error> {
        let address = value.recover_signer()?;
        let tx = value.strip_signature();

        Ok(Self {
            signer: address,
            to: tx.to,
            nonce: tx.nonce,
            value: tx.value,
            chain_id: tx.chain_id(),
            gas_limit: U256::from(tx.gas_limit()),
            max_priority_fee_per_gas: U256::from(tx.gas_price),
            max_fee_per_gas: U256::from(tx.gas_price),
            data: tx.input,
            access_list: tx.access_list,
        })
    }
}

impl TryFrom<Signed<TxLegacy>> for NormalizedEthTransaction {
    type Error = Error;

    fn try_from(value: Signed<TxLegacy>) -> Result<Self, Self::Error> {
        let address = value.recover_signer()?;
        let tx = value.strip_signature();

        Ok(Self {
            signer: address,
            to: tx.to,
            nonce: tx.nonce,
            value: tx.value,
            chain_id: tx.chain_id(),
            gas_limit: U256::from(tx.gas_limit()),
            max_priority_fee_per_gas: U256::from(tx.gas_price),
            max_fee_per_gas: U256::from(tx.gas_price),
            data: tx.input,
            access_list: AccessList(Vec::new()),
        })
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Deserialize, Serialize)]
pub enum ScriptOrModule {
    Script(Script),
    Module(Module),
}

pub(crate) trait ToLog {
    fn to_log(&self) -> Log<LogData>;
}

impl ToLog for ContractEvent {
    fn to_log(&self) -> Log<LogData> {
        let (type_tag, event_data) = match self {
            ContractEvent::V1(event) => (event.type_tag(), event.event_data()),
            ContractEvent::V2(event) => (event.type_tag(), event.event_data()),
        };

        let address = match type_tag {
            TypeTag::Struct(struct_tag) => struct_tag.address,
            _ => unreachable!("This would break move event extension invariant"),
        };

        let address = address.to_eth_address();

        let mut hasher = Keccak256::new();
        let type_string = type_tag.to_canonical_string();
        hasher.update(type_string.as_bytes());
        let type_hash = hasher.finalize();

        let topics = vec![type_hash];

        let data = event_data.to_vec();
        let data = data.into();

        Log::new_unchecked(address, topics, data)
    }
}

#[cfg(test)]
mod tests {
    use {
        super::*,
        alloy_primitives::{address, hex, keccak256},
        alloy_rlp::{Decodable, Encodable},
        aptos_types::contract_event::{ContractEvent, ContractEventV2},
        move_core_types::{
            identifier::Identifier,
            language_storage::{StructTag, TypeTag},
        },
    };

    #[test]
    fn test_move_event_converts_to_eth_log_successfully() {
        let data = vec![0u8, 1, 2, 3];
        let type_tag = TypeTag::Struct(Box::new(StructTag {
            address: hex!("0000111122223333444455556666777788889999aaaabbbbccccddddeeeeffff")
                .into(),
            module: Identifier::new("moved").unwrap(),
            name: Identifier::new("test").unwrap(),
            type_args: vec![],
        }));
        let event = ContractEvent::V2(ContractEventV2::new(type_tag, data));

        let actual_log = event.to_log();
        let expected_log = Log::new_unchecked(
            address!("6666777788889999aaaabbbbccccddddeeeeffff"),
            vec![keccak256(
                "0000111122223333444455556666777788889999aaaabbbbccccddddeeeeffff::moved::test",
            )],
            Bytes::from([0u8, 1, 2, 3]),
        );

        assert_eq!(actual_log, expected_log);
    }

    #[test]
    fn test_extended_tx_envelope_rlp() {
        // Deposited Transaction
        rlp_roundtrip(&Bytes::from_static(&hex!("7ef8f8a0672dfee56b1754d9fb99b11dae8eab6dfb7246470f6f7354d7acab837eab12b294deaddeaddeaddeaddeaddeaddeaddeaddead00019442000000000000000000000000000000000000158080830f424080b8a4440a5e2000000558000c5fc50000000000000004000000006672f4bd000000000000020e00000000000000000000000000000000000000000000000000000000000000070000000000000000000000000000000000000000000000000000000000000001bc6d63f57e9fd865ae9a204a4db7fe1cff654377442541b06d020ddab88c2eeb000000000000000000000000e25583099ba105d9ec0a67f5ae86d90e50036425")));

        // Canonical Transaction
        rlp_roundtrip(&Bytes::from_static(&hex!("02f86f82a45580808346a8928252089465d08a056c17ae13370565b04cf77d2afa1cb9fa8806f05b59d3b2000080c080a0dd50efde9a4d2f01f5248e1a983165c8cfa5f193b07b4b094f4078ad4717c1e4a017db1be1e8751b09e033bcffca982d0fe4919ff6b8594654e06647dee9292750")));
    }

    #[cfg(test)]
    fn rlp_roundtrip(encoded: &[u8]) {
        let mut re_encoded = Vec::with_capacity(encoded.len());
        let mut slice = encoded;
        let tx = ExtendedTxEnvelope::decode(&mut slice).unwrap();
        tx.encode(&mut re_encoded);
        assert_eq!(re_encoded, encoded);
    }
}
