use {
    alloy::{
        consensus::{
            Receipt, ReceiptWithBloom, Signed, Transaction, TxEip1559, TxEip2930, TxEnvelope,
            TxLegacy,
        },
        eips::eip2930::AccessList,
        primitives::{Address, B256, Bloom, Bytes, Log, LogData, TxKind, U256, address},
        rpc::types::TransactionRequest,
    },
    aptos_types::transaction::{EntryFunction, Module, Script},
    move_core_types::{account_address::AccountAddress, language_storage::ModuleId},
    op_alloy::consensus::{
        OpDepositReceipt, OpDepositReceiptWithBloom, OpReceiptEnvelope, OpTxEnvelope, TxDeposit,
    },
    serde::{Deserialize, Serialize},
    std::borrow::Cow,
    umi_shared::{
        error::{Error, InvalidTransactionCause, UserError},
        primitives::ToMoveAddress,
    },
};

pub const L2_LOWEST_ADDRESS: Address = address!("4200000000000000000000000000000000000000");
pub const L2_HIGHEST_ADDRESS: Address = address!("42000000000000000000000000000000000000ff");
pub const DEPOSIT_RECEIPT_VERSION: u64 = 1;

pub trait WrapReceipt {
    fn wrap_receipt(&self, receipt: Receipt, bloom: Bloom) -> OpReceiptEnvelope;
}

impl WrapReceipt for OpTxEnvelope {
    fn wrap_receipt(&self, receipt: Receipt, bloom: Bloom) -> OpReceiptEnvelope {
        match self {
            Self::Legacy(_) => OpReceiptEnvelope::Legacy(ReceiptWithBloom {
                receipt,
                logs_bloom: bloom,
            }),
            Self::Eip1559(_) => OpReceiptEnvelope::Eip1559(ReceiptWithBloom {
                receipt,
                logs_bloom: bloom,
            }),
            Self::Eip2930(_) => OpReceiptEnvelope::Eip2930(ReceiptWithBloom {
                receipt,
                logs_bloom: bloom,
            }),
            Self::Deposit(dep) => {
                OpReceiptEnvelope::Deposit(OpDepositReceiptWithBloom {
                    receipt: OpDepositReceipt {
                        inner: receipt,
                        // Per OP stack spec <https://specs.optimism.io/protocol/deposits.html#execution>
                        deposit_nonce: Some(dep.nonce()),
                        deposit_receipt_version: Some(DEPOSIT_RECEIPT_VERSION),
                    },
                    logs_bloom: bloom,
                })
            }
            _ => unreachable!("Wrapping of other tx types not supported"),
        }
    }
}

#[derive(Debug, Clone)]
pub enum NormalizedExtendedTxEnvelope {
    Canonical(NormalizedEthTransaction),
    DepositedTx(TxDeposit),
}

impl TryFrom<OpTxEnvelope> for NormalizedExtendedTxEnvelope {
    type Error = Error;

    fn try_from(value: OpTxEnvelope) -> Result<Self, Self::Error> {
        Ok(match value {
            OpTxEnvelope::Eip1559(tx) => NormalizedExtendedTxEnvelope::Canonical(tx.try_into()?),
            OpTxEnvelope::Eip2930(tx) => NormalizedExtendedTxEnvelope::Canonical(tx.try_into()?),
            OpTxEnvelope::Legacy(tx) => NormalizedExtendedTxEnvelope::Canonical(tx.try_into()?),
            OpTxEnvelope::Deposit(tx) => NormalizedExtendedTxEnvelope::DepositedTx(tx.unseal()),
            _ => Err(InvalidTransactionCause::UnsupportedType)?,
        })
    }
}

impl NormalizedExtendedTxEnvelope {
    pub fn into_canonical(self) -> Option<NormalizedEthTransaction> {
        if let Self::Canonical(tx) = self {
            Some(tx)
        } else {
            None
        }
    }

    pub fn tip_per_gas(&self, base_fee: U256) -> U256 {
        match self {
            Self::DepositedTx(..) => U256::ZERO,
            Self::Canonical(tx) => tx.tip_per_gas(base_fee),
        }
    }

    pub fn gas_limit(&self) -> u64 {
        match self {
            Self::DepositedTx(..) => 0,
            Self::Canonical(tx) => tx.gas_limit(),
        }
    }

    pub fn effective_gas_price(&self, base_fee: U256) -> U256 {
        match self {
            Self::DepositedTx(..) => U256::ZERO,
            Self::Canonical(tx) => tx.effective_gas_price(base_fee),
        }
    }
}

type MoveChanges = umi_state::Changes;
type EvmChanges = umi_evm_ext::state::StorageTriesChanges;

#[derive(Debug, Clone)]
pub struct Changes {
    pub move_vm: MoveChanges,
    pub evm: EvmChanges,
}

impl Changes {
    pub fn new(move_vm: MoveChanges, evm: EvmChanges) -> Self {
        Self { move_vm, evm }
    }
}

impl From<MoveChanges> for Changes {
    fn from(value: MoveChanges) -> Self {
        Self::new(value, EvmChanges::empty())
    }
}

#[derive(Debug)]
pub struct TransactionExecutionOutcome {
    /// The final outcome of the transaction execution.
    ///
    /// * In case of invalid user input, the result variant is set to [`Err`] containing the actual
    ///   [`UserError`].
    /// * Otherwise, the result variant is set to [`Ok`] containing no data represented by an empty
    ///   tuple.
    pub vm_outcome: Result<(), UserError>,
    /// All changes to accounts and resources generated by the transaction execution to be applied
    /// to Move blockchain state.
    pub changes: Changes,
    /// Total amount of gas spent during the transaction execution.
    pub gas_used: u64,
    /// Effective L2 gas price during transaction execution.
    pub l2_price: U256,
    /// All emitted Move events converted to Ethereum logs.
    pub logs: Vec<Log<LogData>>,
    /// AccountAddress + ModuleId of a deployed module (if any).
    pub deployment: Option<(AccountAddress, ModuleId)>,
}

impl TransactionExecutionOutcome {
    pub fn new(
        vm_outcome: Result<(), UserError>,
        changes: Changes,
        gas_used: u64,
        l2_price: U256,
        logs: Vec<Log<LogData>>,
        deployment: Option<(AccountAddress, ModuleId)>,
    ) -> Self {
        Self {
            vm_outcome,
            changes,
            gas_used,
            l2_price,
            logs,
            deployment,
        }
    }
}

#[derive(Debug, Clone)]
pub struct NormalizedEthTransaction {
    pub signer: Address,
    pub to: TxKind,
    pub nonce: u64,
    pub value: U256,
    pub data: Bytes,
    pub chain_id: Option<u64>,
    gas_limit: U256,
    pub max_priority_fee_per_gas: U256,
    pub max_fee_per_gas: U256,
    pub access_list: AccessList,
}

impl NormalizedEthTransaction {
    pub fn gas_limit(&self) -> u64 {
        // Gas limit cannot be larger than a `u64`, so
        // if any higher limb is non-zero simply return `u64::MAX`.
        match self.gas_limit.into_limbs() {
            [x, 0, 0, 0] => x,
            _ => u64::MAX,
        }
    }
}

impl TryFrom<TxEnvelope> for NormalizedEthTransaction {
    type Error = Error;

    fn try_from(tx: TxEnvelope) -> Result<Self, Self::Error> {
        Ok(match tx {
            TxEnvelope::Eip1559(tx) => tx.try_into()?,
            TxEnvelope::Eip2930(tx) => tx.try_into()?,
            TxEnvelope::Legacy(tx) => tx.try_into()?,
            TxEnvelope::Eip4844(_) | TxEnvelope::Eip7702(_) => {
                Err(InvalidTransactionCause::UnsupportedType)?
            }
        })
    }
}

impl TryFrom<Signed<TxEip1559>> for NormalizedEthTransaction {
    type Error = Error;

    fn try_from(value: Signed<TxEip1559>) -> Result<Self, Self::Error> {
        let address = value.recover_signer()?;
        let tx = value.strip_signature();

        Ok(Self {
            signer: address,
            to: tx.to,
            nonce: tx.nonce,
            value: tx.value,
            chain_id: tx.chain_id(),
            gas_limit: U256::from(tx.gas_limit()),
            max_priority_fee_per_gas: U256::from(tx.max_priority_fee_per_gas),
            max_fee_per_gas: U256::from(tx.max_fee_per_gas),
            data: tx.input,
            access_list: tx.access_list,
        })
    }
}

impl TryFrom<Signed<TxEip2930>> for NormalizedEthTransaction {
    type Error = Error;

    fn try_from(value: Signed<TxEip2930>) -> Result<Self, Self::Error> {
        let address = value.recover_signer()?;
        let tx = value.strip_signature();

        Ok(Self {
            signer: address,
            to: tx.to,
            nonce: tx.nonce,
            value: tx.value,
            chain_id: tx.chain_id(),
            gas_limit: U256::from(tx.gas_limit()),
            max_priority_fee_per_gas: U256::from(tx.gas_price),
            max_fee_per_gas: U256::from(tx.gas_price),
            data: tx.input,
            access_list: tx.access_list,
        })
    }
}

impl TryFrom<Signed<TxLegacy>> for NormalizedEthTransaction {
    type Error = Error;

    fn try_from(value: Signed<TxLegacy>) -> Result<Self, Self::Error> {
        let address = value.recover_signer()?;
        let tx = value.strip_signature();

        Ok(Self {
            signer: address,
            to: tx.to,
            nonce: tx.nonce,
            value: tx.value,
            chain_id: tx.chain_id(),
            gas_limit: U256::from(tx.gas_limit()),
            max_priority_fee_per_gas: U256::from(tx.gas_price),
            max_fee_per_gas: U256::from(tx.gas_price),
            data: tx.input,
            access_list: AccessList(Vec::new()),
        })
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Deserialize, Serialize)]
pub enum ScriptOrDeployment {
    Script(Script),
    Module(Module),
    EvmContract(Vec<u8>),
}

/// Possible parsings of transaction data from a non-deposit transaction.
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum TransactionData {
    EoaBaseTokenTransfer(Address),
    ScriptOrDeployment(ScriptOrDeployment),
    EntryFunction(EntryFunction),
    L2Contract(Address),
    EvmContract { address: Address, data: Vec<u8> },
}

impl TransactionData {
    pub fn parse_from(tx: &NormalizedEthTransaction) -> umi_shared::error::Result<Self> {
        match tx.to {
            TxKind::Call(to) => {
                if to.ge(&L2_LOWEST_ADDRESS) && to.le(&L2_HIGHEST_ADDRESS) {
                    Ok(Self::L2Contract(to))
                } else if tx.data.is_empty() {
                    // When there is no transaction data then we interpret the
                    // transaction as a base token transfer between EOAs.
                    Ok(Self::EoaBaseTokenTransfer(to))
                } else {
                    let tx_data: SerializableTransactionData = bcs::from_bytes(&tx.data)?;
                    // Inner value should be an entry function type or EVM contract.
                    match tx_data {
                        SerializableTransactionData::EntryFunction(entry_fn) => {
                            if entry_fn.module().address() != &to.to_move_address() {
                                Err(InvalidTransactionCause::InvalidDestination)?
                            }
                            Ok(TransactionData::EntryFunction(entry_fn.into_owned()))
                        }
                        SerializableTransactionData::EvmContract { data } => {
                            Ok(TransactionData::EvmContract {
                                address: to,
                                data: data.into_owned(),
                            })
                        }
                        _ => Err(InvalidTransactionCause::InvalidPayload(bcs::Error::Custom(
                            "Expected entry function or EVM contract".to_string(),
                        )))?,
                    }
                }
            }
            TxKind::Create => {
                // Assume EVM create type transactions are either scripts or module deployments
                let script_or_module: ScriptOrDeployment = bcs::from_bytes(&tx.data)?;
                Ok(Self::ScriptOrDeployment(script_or_module))
            }
        }
    }

    /// Serialize this type into bytes suitable for using in the `data` field of
    /// an Ethereum transaction.
    pub fn to_bytes(&self) -> Result<Vec<u8>, bcs::Error> {
        let serializable: SerializableTransactionData = self.into();
        bcs::to_bytes(&serializable)
    }

    pub fn maybe_entry_fn(&self) -> Option<&EntryFunction> {
        if let Self::EntryFunction(entry_fn) = self {
            Some(entry_fn)
        } else {
            None
        }
    }

    pub fn script_hash(&self) -> Option<B256> {
        if let Self::ScriptOrDeployment(ScriptOrDeployment::Script(script)) = self {
            let bytes = bcs::to_bytes(script).expect("Script must serialize");
            let hash = alloy::primitives::keccak256(bytes);
            Some(hash)
        } else {
            None
        }
    }
}

impl From<TransactionRequest> for NormalizedEthTransaction {
    fn from(value: TransactionRequest) -> Self {
        Self {
            signer: value.from.unwrap_or_default(),
            to: value.to.unwrap_or_default(),
            nonce: value.nonce.unwrap_or_default(),
            value: value.value.unwrap_or_default(),
            chain_id: value.chain_id,
            gas_limit: U256::from(value.gas.unwrap_or(u64::MAX)),
            max_priority_fee_per_gas: U256::from(
                value.max_priority_fee_per_gas.unwrap_or_default(),
            ),
            max_fee_per_gas: U256::from(value.max_fee_per_gas.unwrap_or_default()),
            data: value.input.into_input().unwrap_or_default(),
            access_list: value.access_list.unwrap_or_default(),
        }
    }
}

// Intentionally left private to hide the serialization details
// from users of `TransactionData`. This allows making changes to
// `TransactionData` itself while remaining backwards compatible with
// the serialization format.
// The purpose of `Cow` wrapping all the data is to allow serializing
// from a reference to `TransactionData` without cloning while also allowing
// deserializing to `SerializableTransactionData` with owned data.
// Data type which are `Copy` are left without `Cow` references.
#[derive(Deserialize, Serialize)]
enum SerializableTransactionData<'a> {
    EoaBaseTokenTransfer(Address),
    ScriptOrDeployment(Cow<'a, ScriptOrDeployment>),
    // Entry function should be the 3rd option to match the SDK TransactionPayload
    EntryFunction(Cow<'a, EntryFunction>),
    L2Contract(Address),
    // Note: we only include the data here not the address as in the `TransactionData` type
    // because the address is taken from the Ethereum transaction `to` field. Therefore
    // encoding it here would be redundant.
    EvmContract { data: Cow<'a, [u8]> },
}

impl<'a> From<&'a TransactionData> for SerializableTransactionData<'a> {
    fn from(value: &'a TransactionData) -> Self {
        match value {
            TransactionData::EoaBaseTokenTransfer(to) => Self::EoaBaseTokenTransfer(*to),
            TransactionData::ScriptOrDeployment(x) => Self::ScriptOrDeployment(Cow::Borrowed(x)),
            TransactionData::EntryFunction(x) => Self::EntryFunction(Cow::Borrowed(x)),
            TransactionData::L2Contract(x) => Self::L2Contract(*x),
            TransactionData::EvmContract { data, .. } => Self::EvmContract {
                data: Cow::Borrowed(data),
            },
        }
    }
}

#[cfg(test)]
mod tests {
    use {
        super::*,
        alloy::{
            consensus::Sealed,
            primitives::{address, hex},
        },
    };

    #[test]
    fn test_deposited_tx_hash() {
        let tx = OpTxEnvelope::Deposit(Sealed::new(TxDeposit{
            source_hash: B256::new(hex!("ad2cd5c72f8d6b25e4da049d76790993af597050965f2aee87e12f98f8c2427f")),
            from: address!("4a04a3191b7a44a99bfd3184f0d2c2c82b98b939"),
            to: TxKind::Call(address!("4200000000000000000000000000000000000007")),
            mint: Some(0x56bc75e2d63100000_u128),
            value: U256::from(0x56bc75e2d63100000_u128),
            gas_limit: 0x77d2e_u64,
            is_system_transaction: false,
            input: hex!("d764ad0b0001000000000000000000000000000000000000000000000000000000000000000000000000000000000000c8088d0362bb4ac757ca77e211c30503d39cef4800000000000000000000000042000000000000000000000000000000000000100000000000000000000000000000000000000000000000056bc75e2d631000000000000000000000000000000000000000000000000000000000000000030d4000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000a41635f5fd00000000000000000000000084a124e4ec6f0f9914b49dcc71669a8cac556ad600000000000000000000000084a124e4ec6f0f9914b49dcc71669a8cac556ad60000000000000000000000000000000000000000000000056bc75e2d631000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000").into(),
        }));
        assert_eq!(
            tx.tx_hash(),
            B256::new(hex!(
                "ab9985077953a6544cd83c3c2a0ade7de83c19254124a74f5e9644ee8be4fc2f"
            ))
        );
    }
}
