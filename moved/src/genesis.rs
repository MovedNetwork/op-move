use {
    crate::move_execution::create_move_vm,
    crate::storage::Storage,
    aptos_framework::ReleaseBundle,
    aptos_table_natives::{NativeTableContext, TableChange, TableChangeSet},
    move_binary_format::errors::PartialVMError,
    move_core_types::{
        account_address::AccountAddress,
        effects::{ChangeSet, Op},
    },
    move_vm_runtime::{native_extensions::NativeContextExtensions, session::Session},
    move_vm_types::gas::UnmeteredGasMeter,
    once_cell::sync::Lazy,
    std::collections::BTreeMap,
    std::fs,
    std::path::PathBuf,
    sui_framework::SystemPackage,
    sui_types::base_types::ObjectID,
};

pub const CRATE_ROOT: &str = env!("CARGO_MANIFEST_DIR");
pub const APTOS_SNAPSHOT_NAME: &str = "head.mrb";
pub const SUI_SNAPSHOT_NAME: &str = "sui.mrb";
pub const FRAMEWORK_ADDRESS: AccountAddress = AccountAddress::ONE;
pub const TOKEN_ADDRESS: AccountAddress = AccountAddress::THREE;
pub const TOKEN_OBJECT_ADDRESS: AccountAddress = AccountAddress::FOUR;
pub const SUI_STDLIB_ADDRESS: AccountAddress = small_account_address(0x21);
pub const SUI_FRAMEWORK_ADDRESS: AccountAddress = small_account_address(0x22);
pub const SUI_STDLIB_PACKAGE_ID: ObjectID = small_object_id(0x21);
pub const SUI_FRAMEWORK_PACKAGE_ID: ObjectID = small_object_id(0x22);

// The `head.mrb` file is generated by running the following inside an aptos-core repo
// cargo run --package aptos-framework -- release
static APTOS_RELEASE_BUNDLE: Lazy<ReleaseBundle> = Lazy::new(|| {
    let snapshot_path = PathBuf::from(CRATE_ROOT).join(APTOS_SNAPSHOT_NAME);
    let binary = fs::read(snapshot_path).expect("Aptos snapshot file should exist");
    bcs::from_bytes(&binary).expect("bcs should deserialize Aptos file")
});

static SUI_SYSTEM_PACKAGES: Lazy<BTreeMap<ObjectID, SystemPackage>> = Lazy::new(|| {
    let snapshot_path = PathBuf::from(CRATE_ROOT).join(SUI_SNAPSHOT_NAME);
    let binary = fs::read(snapshot_path).expect("Sui snapshot file should exist");
    let snapshot: Vec<SystemPackage> =
        bcs::from_bytes(&binary).expect("bcs should deserialize Sui snapshot file");
    snapshot.into_iter().map(|pkg| (pkg.id, pkg)).collect()
});

const fn small_account_address(value: u8) -> AccountAddress {
    let mut buf = [0u8; 32];
    buf[31] = value;
    AccountAddress::new(buf)
}

const fn small_object_id(value: u8) -> ObjectID {
    ObjectID::from_single_byte(value)
}

/// Returns the Aptos framework release bundle
pub fn load_aptos_framework_snapshot() -> &'static ReleaseBundle {
    &APTOS_RELEASE_BUNDLE
}

/// Returns the Sui framework release bundle
pub fn load_sui_framework_snapshot() -> &'static BTreeMap<ObjectID, SystemPackage> {
    &SUI_SYSTEM_PACKAGES
}

/// Initializes the in-memory storage with Aptos and Sui frameworks.
pub fn init_storage(storage: &mut impl Storage<Err = PartialVMError>) {
    let (change_set, table_change_set) =
        deploy_framework(storage).expect("All bundle modules should be valid");

    // This function converts a `TableChange` to a move table extension struct.
    // InMemoryStorage relies on this conversion to apply the storage changes correctly.
    let convert_to_move_extension_table_change = |aptos_table_change: TableChange| {
        let entries = aptos_table_change
            .entries
            .into_iter()
            .map(|(key, op)| {
                let new_op = match op {
                    Op::New((bytes, _)) => Op::New(bytes),
                    Op::Modify((bytes, _)) => Op::Modify(bytes),
                    Op::Delete => Op::Delete,
                };
                (key, new_op)
            })
            .collect::<BTreeMap<_, _>>();

        move_table_extension::TableChange { entries }
    };
    let table_change_set = move_table_extension::TableChangeSet {
        new_tables: table_change_set.new_tables,
        removed_tables: table_change_set.removed_tables,
        changes: table_change_set
            .changes
            .into_iter()
            .map(|(k, v)| (k, convert_to_move_extension_table_change(v)))
            .collect(),
    };

    storage
        .apply_with_tables(change_set, table_change_set)
        .unwrap();
}

fn deploy_framework(
    storage: &mut impl Storage<Err = PartialVMError>,
) -> anyhow::Result<(ChangeSet, TableChangeSet)> {
    let vm = create_move_vm()?;
    let mut extensions = NativeContextExtensions::default();
    extensions.add(NativeTableContext::new([0u8; 32], storage));
    let mut session = vm.new_session_with_extensions(storage, extensions);

    deploy_aptos_framework(&mut session)?;
    deploy_sui_framework(&mut session)?;

    let (change_set, mut extensions) = session.finish_with_extensions()?;
    let table_change_set = extensions
        .remove::<NativeTableContext>()
        .into_change_set()?;

    Ok((change_set, table_change_set))
}

fn deploy_aptos_framework(session: &mut Session) -> anyhow::Result<()> {
    let framework = load_aptos_framework_snapshot();
    // Iterate over the bundled packages in the Aptos framework
    for package in &framework.packages {
        let modules = package.sorted_code_and_modules();
        // Address from the first module is sufficient as they're the same within the package
        let sender = modules.first().expect("Package has at least one module");
        let sender = *sender.1.self_id().address();

        assert!(
            sender == FRAMEWORK_ADDRESS
                || sender == TOKEN_ADDRESS
                || sender == TOKEN_OBJECT_ADDRESS,
            "The framework should be deployed to a statically known address. {sender} not known."
        );

        let code = modules
            .into_iter()
            .map(|(code, _)| code.to_vec())
            .collect::<Vec<_>>();

        session.publish_module_bundle(code, sender, &mut UnmeteredGasMeter)?;
    }
    Ok(())
}

fn deploy_sui_framework(session: &mut Session) -> anyhow::Result<()> {
    // Load the framework packages from the framework snapshot
    let snapshots = load_sui_framework_snapshot();
    let stdlib = snapshots
        .get(&SUI_STDLIB_PACKAGE_ID)
        .expect("Sui Move Stdlib package should exist in snapshot")
        .to_owned();
    let framework = snapshots
        .get(&SUI_FRAMEWORK_PACKAGE_ID)
        .expect("Sui Framework package should exist in snapshot")
        .to_owned();

    let mut gas = UnmeteredGasMeter;
    session.publish_module_bundle(stdlib.bytes, SUI_STDLIB_ADDRESS, &mut gas)?;
    session.publish_module_bundle(framework.bytes, SUI_FRAMEWORK_ADDRESS, &mut gas)?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use std::process::Command;

    use super::*;
    use aptos_framework::{BuildOptions, BuiltPackage, ReleasePackage};
    use move_vm_test_utils::InMemoryStorage;

    // Aptos framework has 113 modules and Sui has 70. They are kept mutually exclusive.
    const APTOS_MODULES_LEN: usize = 113;
    const SUI_MODULES_LEN: usize = 70;
    const TOTAL_MODULES_LEN: usize = 183;

    #[test]
    fn test_deploy_framework() {
        let aptos_framework_len = load_aptos_framework_snapshot()
            .code_and_compiled_modules()
            .len();
        assert_eq!(aptos_framework_len, APTOS_MODULES_LEN);
        let sui_framework_len = load_sui_framework_snapshot()
            .iter()
            .map(|(_id, pkg)| pkg.modules())
            .flatten()
            .count();
        assert_eq!(sui_framework_len, SUI_MODULES_LEN);

        let mut storage = InMemoryStorage::new();
        let (change_set, _) = deploy_framework(&mut storage).unwrap();
        assert_eq!(change_set.modules().count(), TOTAL_MODULES_LEN);
    }

    #[cfg(unix)]
    const CUSTOM_RELEASE_BUNDLE_BYTES: &[u8] = include_bytes!("../../custom/custom.mrb");
    #[cfg(windows)]
    const CUSTOM_RELEASE_BUNDLE_BYTES: &[u8] = include_bytes!("../../custom/custom.mrb");

    static CUSTOM_RELEASE_BUNDLE: Lazy<ReleaseBundle> = Lazy::new(|| {
        bcs::from_bytes::<ReleaseBundle>(CUSTOM_RELEASE_BUNDLE_BYTES).expect("bcs succeeds")
    });

    fn custom_release_bundle() -> &'static ReleaseBundle {
        &CUSTOM_RELEASE_BUNDLE
    }

    #[test]
    fn test_aptos_framework_custom_release() {
        let packages = vec![
            PathBuf::from("move-stdlib"),
            PathBuf::from("aptos-stdlib"),
            PathBuf::from("aptos-framework"),
            PathBuf::from("aptos-token"),
            PathBuf::from("aptos-token-objects"),
        ];

        let rust_bindings = vec!["".to_string(); 5];
        let output = PathBuf::from("custom.mrb");
        let mut command = Command::new("../custom/bin/aptos-framework");

        command
            .current_dir("../custom")
            .arg("custom")
            .arg("--skip-attribute-checks")
            .arg("--output")
            .arg(output);

        for package in &packages {
            command.arg("--packages").arg(package);
        }
        for binding in &rust_bindings {
            command.arg("--rust-bindings").arg(binding);
        }

        let output = command.output().expect("Failed to execute command");
        println!("Status: {}", output.status);
        println!("Stdout: {}", String::from_utf8_lossy(&output.stdout));
        println!("Stderr: {}", String::from_utf8_lossy(&output.stderr));

        const CUSTOM_RELEASE_BUNDLE_MODULES_LEN: usize = 77;
        assert_eq!(
            custom_release_bundle().code_and_compiled_modules().len(),
            CUSTOM_RELEASE_BUNDLE_MODULES_LEN
        );
    }

    #[test]
    fn test_genesis_builder() {
        const APTOS_RELEASE_BUNDLE_BYTES: &[u8] = include_bytes!("../aptos.mrb");

        static APTOS_RELEASE_BUNDLE: Lazy<ReleaseBundle> = Lazy::new(|| {
            bcs::from_bytes::<ReleaseBundle>(APTOS_RELEASE_BUNDLE_BYTES).expect("bcs succeeds")
        });

        fn aptos_release_bundle() -> &'static ReleaseBundle {
            &APTOS_RELEASE_BUNDLE
        }

        const APTOS_RELEASE_BUNDLE_MODULES_LEN: usize = 77;
        assert_eq!(
            aptos_release_bundle().code_and_compiled_modules().len(),
            APTOS_RELEASE_BUNDLE_MODULES_LEN
        );
    }

    // TODO: move to own crate
    // This is the entire functionaly of the genesis builder crate
    fn _genesis_builder() {
        let packages_path = vec![
            PathBuf::from("../custom/move-stdlib"),
            PathBuf::from("../custom/aptos-stdlib"),
            PathBuf::from("../custom/aptos-framework"),
            PathBuf::from("../custom/aptos-token"),
            PathBuf::from("../custom/aptos-token-objects"),
        ];

        let packages = packages_path
            .iter()
            .map(|path| {
                ReleasePackage::new(
                    BuiltPackage::build(path.to_path_buf(), BuildOptions::default()).unwrap(),
                )
                .unwrap()
            })
            .collect::<Vec<_>>();

        let release_bundle = ReleaseBundle::new(
            packages,
            packages_path
                .into_iter()
                .map(|path| path.to_string_lossy().into_owned())
                .collect(),
        );

        let binary = bcs::to_bytes(&release_bundle).unwrap();
        fs::write("aptos.mrb", binary).unwrap();
        println!("Generated release bundle");
    }
}
