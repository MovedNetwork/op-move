use {
    crate::{genesis::config::GenesisConfig, move_execution::create_move_vm, storage::State},
    aptos_framework::ReleaseBundle,
    aptos_table_natives::{NativeTableContext, TableChange, TableChangeSet},
    move_binary_format::errors::PartialVMError,
    move_core_types::{
        account_address::AccountAddress,
        effects::{ChangeSet, Op},
        ident_str,
        language_storage::ModuleId,
        value::MoveValue,
    },
    move_vm_runtime::{
        module_traversal::{TraversalContext, TraversalStorage},
        native_extensions::NativeContextExtensions,
        session::Session,
    },
    move_vm_types::gas::UnmeteredGasMeter,
    once_cell::sync::Lazy,
    std::{collections::BTreeMap, fs, path::PathBuf},
    sui_framework::SystemPackage,
    sui_types::base_types::ObjectID,
};

pub const CRATE_ROOT: &str = env!("CARGO_MANIFEST_DIR");
pub const APTOS_SNAPSHOT_NAME: &str = "aptos.mrb";
pub const SUI_SNAPSHOT_NAME: &str = "sui.mrb";
pub const FRAMEWORK_ADDRESS: AccountAddress = AccountAddress::ONE;
pub const TOKEN_ADDRESS: AccountAddress = small_account_address(0x13);
pub const TOKEN_OBJECT_ADDRESS: AccountAddress = small_account_address(0x14);
pub const SUI_STDLIB_ADDRESS: AccountAddress = small_account_address(0x21);
pub const SUI_FRAMEWORK_ADDRESS: AccountAddress = small_account_address(0x22);
pub const SUI_STDLIB_PACKAGE_ID: ObjectID = small_object_id(0x21);
pub const SUI_FRAMEWORK_PACKAGE_ID: ObjectID = small_object_id(0x22);

// The `head.mrb` file is generated by running the following inside an aptos-core repo
// cargo run --package aptos-framework -- release
static APTOS_RELEASE_BUNDLE: Lazy<ReleaseBundle> = Lazy::new(|| {
    let snapshot_path = PathBuf::from(CRATE_ROOT).join(APTOS_SNAPSHOT_NAME);
    let binary = fs::read(snapshot_path).expect("Aptos snapshot file should exist");
    bcs::from_bytes(&binary).expect("bcs should deserialize Aptos file")
});

static SUI_SYSTEM_PACKAGES: Lazy<BTreeMap<ObjectID, SystemPackage>> = Lazy::new(|| {
    let snapshot_path = PathBuf::from(CRATE_ROOT).join(SUI_SNAPSHOT_NAME);
    let binary = fs::read(snapshot_path).expect("Sui snapshot file should exist");
    let snapshot: Vec<SystemPackage> =
        bcs::from_bytes(&binary).expect("bcs should deserialize Sui snapshot file");
    snapshot.into_iter().map(|pkg| (pkg.id, pkg)).collect()
});

const fn small_account_address(value: u8) -> AccountAddress {
    let mut buf = [0u8; 32];
    buf[31] = value;
    AccountAddress::new(buf)
}

const fn small_object_id(value: u8) -> ObjectID {
    ObjectID::from_single_byte(value)
}

/// Returns the Aptos framework release bundle
pub fn load_aptos_framework_snapshot() -> &'static ReleaseBundle {
    &APTOS_RELEASE_BUNDLE
}

/// Returns the Sui framework release bundle
pub fn load_sui_framework_snapshot() -> &'static BTreeMap<ObjectID, SystemPackage> {
    &SUI_SYSTEM_PACKAGES
}

/// Initializes the blockchain state with Aptos and Sui frameworks.
pub fn init_state(config: &GenesisConfig, state: &mut impl State<Err = PartialVMError>) {
    let (change_set, table_change_set) =
        deploy_framework(state).expect("All bundle modules should be valid");

    // This function converts a `TableChange` to a move table extension struct.
    // InMemoryStorage relies on this conversion to apply the storage changes correctly.
    let convert_to_move_extension_table_change = |aptos_table_change: TableChange| {
        let entries = aptos_table_change
            .entries
            .into_iter()
            .map(|(key, op)| {
                let new_op = match op {
                    Op::New((bytes, _)) => Op::New(bytes),
                    Op::Modify((bytes, _)) => Op::Modify(bytes),
                    Op::Delete => Op::Delete,
                };
                (key, new_op)
            })
            .collect::<BTreeMap<_, _>>();

        move_table_extension::TableChange { entries }
    };
    let table_change_set = move_table_extension::TableChangeSet {
        new_tables: table_change_set.new_tables,
        removed_tables: table_change_set.removed_tables,
        changes: table_change_set
            .changes
            .into_iter()
            .map(|(k, v)| (k, convert_to_move_extension_table_change(v)))
            .collect(),
    };

    state
        .apply_with_tables(change_set, table_change_set)
        .unwrap();

    let actual_state_root = state.state_root();
    let expected_state_root = config.initial_state_root;

    assert_eq!(
        actual_state_root, expected_state_root,
        "Fatal Error: Genesis state root mismatch"
    );
}

fn deploy_framework(
    storage: &mut impl State<Err = PartialVMError>,
) -> crate::Result<(ChangeSet, TableChangeSet)> {
    let vm = create_move_vm()?;
    let mut extensions = NativeContextExtensions::default();
    extensions.add(NativeTableContext::new([0u8; 32], storage.resolver()));
    let mut session = vm.new_session_with_extensions(storage.resolver(), extensions);
    let traversal_storage = TraversalStorage::new();
    let mut traversal_context = TraversalContext::new(&traversal_storage);

    deploy_aptos_framework(&mut session)?;
    deploy_sui_framework(&mut session)?;
    initialize_eth_token(&mut session, &mut traversal_context)?;

    let (change_set, mut extensions) = session.finish_with_extensions()?;
    let table_change_set = extensions
        .remove::<NativeTableContext>()
        .into_change_set()?;

    Ok((change_set, table_change_set))
}

fn initialize_eth_token(
    session: &mut Session,
    traversal_context: &mut TraversalContext,
) -> crate::Result<()> {
    let module = ModuleId::new(FRAMEWORK_ADDRESS, ident_str!("eth_token").into());
    let function_name = ident_str!("init_module");
    let args = bcs::to_bytes(&MoveValue::Signer(FRAMEWORK_ADDRESS))
        .expect("Serialization of constant must succeed");
    session.execute_function_bypass_visibility(
        &module,
        function_name,
        Vec::new(),
        vec![args],
        &mut UnmeteredGasMeter,
        traversal_context,
    )?;
    Ok(())
}

fn deploy_aptos_framework(session: &mut Session) -> crate::Result<()> {
    let framework = load_aptos_framework_snapshot();
    // Iterate over the bundled packages in the Aptos framework
    for package in &framework.packages {
        let modules = package.sorted_code_and_modules();
        // Address from the first module is sufficient as they're the same within the package
        let sender = modules.first().expect("Package has at least one module");
        let sender = *sender.1.self_id().address();

        assert!(
            sender == FRAMEWORK_ADDRESS
                || sender == TOKEN_ADDRESS
                || sender == TOKEN_OBJECT_ADDRESS,
            "The framework should be deployed to a statically known address. {sender} not known."
        );

        let code = modules
            .into_iter()
            .map(|(code, _)| code.to_vec())
            .collect::<Vec<_>>();

        session.publish_module_bundle(code, sender, &mut UnmeteredGasMeter)?;
    }
    Ok(())
}

fn deploy_sui_framework(session: &mut Session) -> crate::Result<()> {
    // Load the framework packages from the framework snapshot
    let snapshots = load_sui_framework_snapshot();
    let stdlib = snapshots
        .get(&SUI_STDLIB_PACKAGE_ID)
        .expect("Sui Move Stdlib package should exist in snapshot")
        .to_owned();
    let framework = snapshots
        .get(&SUI_FRAMEWORK_PACKAGE_ID)
        .expect("Sui Framework package should exist in snapshot")
        .to_owned();

    let mut gas = UnmeteredGasMeter;
    session.publish_module_bundle(stdlib.bytes, SUI_STDLIB_ADDRESS, &mut gas)?;
    session.publish_module_bundle(framework.bytes, SUI_FRAMEWORK_ADDRESS, &mut gas)?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use {super::*, crate::storage::InMemoryState};

    // Aptos framework has 115 modules and Sui has 69. They are kept mutually exclusive.
    const APTOS_MODULES_LEN: usize = 115;
    const SUI_MODULES_LEN: usize = 69;
    const TOTAL_MODULES_LEN: usize = APTOS_MODULES_LEN + SUI_MODULES_LEN;

    #[test]
    fn test_deploy_framework() {
        let aptos_framework_len = load_aptos_framework_snapshot()
            .code_and_compiled_modules()
            .len();
        assert_eq!(aptos_framework_len, APTOS_MODULES_LEN);
        let sui_framework_len = load_sui_framework_snapshot()
            .iter()
            .flat_map(|(_id, pkg)| pkg.modules())
            .count();
        assert_eq!(sui_framework_len, SUI_MODULES_LEN);

        let mut state = InMemoryState::new();
        let (change_set, _) = deploy_framework(&mut state).unwrap();
        assert_eq!(change_set.modules().count(), TOTAL_MODULES_LEN);
    }
}
